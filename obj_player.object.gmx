<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize

// Declaring all of the varibles for this object before anything else so you don't get any errors.

myDirection = 1;
global.myScore = 0;
global.highScore = 0;

/**Next, I'm going to set an alarm that after 60 steps (1 second in real time) it gives you 1 point. There will be two
nearly identical alarms that set each other up, so as to make an infinite loop. I'm sure there are better ways to do
something like this, but this is how I figured out how to do it myself**/

alarm_set(0,60);

//Oh, and'll we'll have the "border" object display the score
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Add point and set alarm 0
if global.game = 1 { global.myScore += 1 };
if global.myScore &gt; global.highScore {global.highScore = global.myScore};
alarm_set(0,60);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Add point and set alarm 1
if global.game = 1 { global.myScore += 1 };
if global.myScore &gt; global.highScore {global.highScore = global.myScore};

alarm_set(1,60);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Rotate



/**Like in the original scratch game, we want the player to be able to switch the rotation by either pressing space or clicking the mouse. The space
pressing method is already in place, via the "space pressed" event. However, since there is no simple "mouse down?" function in GM:S, 
and the "mouse_pressed" events only trigger when the circle itself is acutally pressed, we need to do a bit of a workaround. Here, I'm using
the "mouse_button_pressed" function, each, each frame, will return 1 or 0 depending on wether the mouse is pressed or not. Plug that into a if/else
and we have the same direction-changing function that the space bar gives us**/

if mouse_check_button_pressed(mb_left) = 1
{
    if myDirection = 1
    {
    myDirection = 0
    }else
    {
    myDirection = 1
    }
};
    

// Now we acutally do the turning! Another simple if/else that subtracts 1 degree each step or adds 1 degree each step depending on thr value of myDirection

if myDirection = 1
{
image_angle += 1.5;
}else
{
image_angle -= 1.5;
};
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Switch Direction

//A simple if/else statment that switches the direction to 1 (Right) if direction is currently 0 (left) and vice versa.

if myDirection = 1
{
myDirection = 0
}else
{
myDirection = 1
};
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
