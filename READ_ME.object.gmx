<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///READ THIS

/**

Well hey.

So I thought I'd explain this program the best I could to aid in your quest to remake/adapt/expand it. Or whatever. Please ignore my horrendous spelling.

The global variables to keep track of (in the form of "global.var") are 

"global.myScore" - This is the score that counts up in "obj_player" and is reset by "obj_play" (the play button) each new game.
"global.highScore" - This is the high score, which is computed each frame in the same place as the normal score.
"global.game" - This is basically the game mode. 0 and 2 are "non" game modes, when global.game is set to 1, the game is in play.

Each object and what it controls/does.

obj_player ~ This is the spinning orange dot that the player controls. Inside it are the score loop (via alarms), the declaration of a few global vars, 
            and all of the code that acutally makes the dot move and switch directions
            
obj_border ~ Nothing I'm pretty sure (just a GUI element basically)

obj_play ~ The play button, it handles the global.game in the way you'd expect and also has it's own movement stuff

obj_text ~ Nothing, just displays

obj_enemy ~ These are the bad blue dots, they mostly just move they way that are suppoused to

obj_engine ~ This controls the spawn-rate and spawning of the enemies, as well as displaying the score (via the "draw" event).


Some random GM:S tips that you may or may not know but will make your dev life way easier.
1) At the top of the screen, next to the magnifiyng glass, you see those icons that have binary and like a paper and an arrow? 
Make sure both of those are clicked! That is syntax error check and code completion, and will help a lot. Syntax error checking
will just tell you if something is messed up (forgeting a closing bracket and stuff like that) and code completion will try to
help you finish typing the function or whatever you've begun, which is really helpful if you forget what exactly you need to do.
Activate it, then outside of the comment, type "draw_" and see all the different functions available. It's like documentation in JS ;)

2) After you have a function [i.e. "instance_create();], how do you remember what arguments go inside? Clicking inside the () will
open a guide in the bar across the bottom of the screen, which will show you what you need to put inside, and also where you are
and what you need to add next. Try clicking inside the () and look at the bottom of the screen. You'll have to remove the // first.**/

//draw_text();

/**
3) Press f1 to bring up the complete manual. You can search for anything ("game controller" for instance) and it will bring up all the functions
and articles relating to your search. Super useful.

4) If you are one of the people I wrote this for, you are pretty good at coding with scratch blocks. When writing GM code, visiualize your
code in scratch blocks, then just make that program in GM, only useing GML. Scratch, JavaScript, and GML are all pretty similar.
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
